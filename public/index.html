<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kosh Tanks</title>
  <!--SERVER_CONFIG-->
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #111;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #fff;
      overflow: hidden;
    }

    h1 {
      font-size: 24px;
      margin-bottom: 12px;
      letter-spacing: 2px;
      font-weight: 800;
    }

    #info-bar {
      display: flex;
      gap: 24px;
      margin-bottom: 8px;
      font-size: 14px;
      color: rgba(255,255,255,0.7);
    }

    canvas {
      border: 2px solid #333;
      display: block;
    }

    /* ── Scoreboard ── */
    #scoreboard {
      display: flex;
      gap: 20px;
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 700;
      flex-wrap: wrap;
      justify-content: center;
    }
    .score-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .score-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    /* ── Lobby overlay ── */
    #lobby {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.92);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    #lobby.hidden { display: none; }

    #lobby h2 {
      font-size: 28px;
      margin-bottom: 20px;
      letter-spacing: 3px;
    }

    .lobby-url {
      background: rgba(255,255,255,0.1);
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      margin-bottom: 20px;
      font-family: monospace;
      letter-spacing: 1px;
    }

    .player-codes {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 900px;
    }

    .player-code-box {
      text-align: center;
      padding: 10px 14px;
      border-radius: 10px;
      min-width: 110px;
    }
    .player-code-box .label { font-size: 11px; opacity: 0.7; margin-bottom: 2px; }
    .player-code-box .code { font-size: 24px; font-weight: 800; letter-spacing: 4px; font-family: monospace; }
    .player-code-box .status { font-size: 11px; margin-top: 4px; }
    .player-code-box .status.connected { color: #4CAF50; }
    .player-code-box .status.waiting { color: rgba(255,255,255,0.4); }

    #lobby-status {
      font-size: 14px;
      color: rgba(255,255,255,0.5);
      margin-top: 12px;
    }

    #qr-code {
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 16px;
      display: inline-block;
    }
    #qr-code svg { display: block; }

    /* ── Player count selector ── */
    .player-count-selector {
      margin-bottom: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .player-count-selector label {
      font-size: 14px;
      color: rgba(255,255,255,0.7);
    }
    .count-buttons { display: flex; gap: 6px; }
    .count-btn {
      width: 36px; height: 36px;
      border: 2px solid rgba(255,255,255,0.3);
      background: transparent;
      color: #fff;
      font-size: 16px; font-weight: 700;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .count-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: rgba(255,255,255,0.1);
    }
    .count-btn.active {
      border-color: #4CAF50;
      background: rgba(76,175,80,0.3);
      color: #4CAF50;
    }

    /* ── Bot controls ── */
    .bot-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 18px;
    }
    .bot-btn {
      padding: 8px 18px;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 1px;
      background: rgba(255,255,255,0.1);
      color: #fff;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .bot-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: rgba(255,255,255,0.15);
    }

    /* ── Room picker overlay ── */
    #room-picker {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #111;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      gap: 20px;
    }
    #room-picker.hidden { display: none; }
    #room-picker h2 {
      font-size: 32px;
      letter-spacing: 4px;
      font-weight: 800;
      margin-bottom: 10px;
    }
    .room-picker-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #room-id-input {
      width: 160px; padding: 12px;
      font-size: 24px; font-weight: 700;
      text-align: center; letter-spacing: 6px;
      text-transform: uppercase;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px; color: #fff; outline: none;
    }
    #room-id-input:focus { border-color: rgba(255,255,255,0.5); }
    #room-id-input::placeholder { color: rgba(255,255,255,0.25); letter-spacing: 4px; }
    .room-btn {
      padding: 14px 28px;
      font-size: 16px; font-weight: 700; letter-spacing: 2px;
      border: none; border-radius: 10px; cursor: pointer;
      color: #fff;
      transition: transform 0.1s;
    }
    .room-btn:active { transform: scale(0.96); }
    #create-room-btn { background: #4CAF50; }
    #join-room-btn { background: #4488FF; }
    .room-picker-divider {
      font-size: 14px;
      color: rgba(255,255,255,0.4);
      letter-spacing: 2px;
    }
    #room-error {
      color: #ff5252;
      font-size: 14px;
      min-height: 20px;
    }

    /* ── Room code badge in lobby ── */
    #room-code-badge {
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 3px;
      background: rgba(255,255,255,0.1);
      padding: 6px 16px;
      border-radius: 8px;
      margin-bottom: 12px;
    }

    /* ── Game container ── */
    #game-container {
      position: relative;
      display: inline-block;
    }

    /* ── Winner overlay ── */
    #winner-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #winner-overlay.show { display: flex; }
    #winner-text {
      font-size: 36px;
      font-weight: 800;
      letter-spacing: 3px;
      margin-bottom: 16px;
    }
    #winner-scores {
      font-size: 16px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 24px;
    }
    #ready-status {
      font-size: 18px;
      font-weight: 600;
      margin-top: 16px;
      text-align: center;
      line-height: 1.8;
    }
    #ready-status .ready { color: #4CAF50; }
    #ready-status .not-ready { color: #ff5252; }
  </style>
</head>
<body>

  <!-- Room Picker -->
  <div id="room-picker">
    <h2>KOSH TANKS</h2>
    <button class="room-btn" id="create-room-btn">CREATE ROOM</button>
    <div class="room-picker-divider">— OR —</div>
    <div class="room-picker-row">
      <input type="text" id="room-id-input" maxlength="4" autocomplete="off"
             inputmode="text" autocapitalize="characters" placeholder="CODE" spellcheck="false">
      <button class="room-btn" id="join-room-btn">JOIN</button>
    </div>
    <div id="room-error"></div>
  </div>

  <div id="scoreboard"></div>

  <div id="info-bar" style="display:none">
    <span id="status-text">Connecting...</span>
  </div>

  <div id="game-container">
    <canvas id="game" width="1800" height="1000"></canvas>

    <!-- Lobby overlay -->
    <div id="lobby">
      <h2>WAITING FOR PLAYERS</h2>
      <div id="room-code-badge"></div>
      <div class="player-count-selector">
        <label>Players:</label>
        <div class="count-buttons" id="count-buttons"></div>
      </div>
      <div class="bot-controls">
        <button class="bot-btn" id="add-bot-btn">+ ADD BOT</button>
        <button class="bot-btn" id="remove-bot-btn">- REMOVE BOT</button>
        <span id="bot-count-label" style="color: rgba(255,255,255,0.5); font-size: 13px; margin-left: 8px;">0 bots</span>
      </div>
      <div class="lobby-url" id="lobby-url"></div>
      <div id="qr-code"></div>
      <div class="player-codes" id="player-codes"></div>
      <div id="lobby-status">Scan the QR code or open the URL on your phone</div>
    </div>

    <!-- Winner overlay -->
    <div id="winner-overlay">
      <div id="winner-text"></div>
      <div id="winner-scores"></div>
      <div id="ready-status">Waiting for players...</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 1800, H = 1000, R = 20, PR = 4;

    function fitCanvas() {
      const maxW = window.innerWidth - 4;
      const maxH = window.innerHeight;
      const scale = Math.min(maxW / W, maxH / H, 1);
      canvas.style.width = (W * scale) + 'px';
      canvas.style.height = (H * scale) + 'px';
    }
    fitCanvas();
    window.addEventListener('resize', fitCanvas);
    const TANK_DISPLAY = 48; // drawn size in pixels

    const PLAYER_HEX_COLORS = [
      '#FF4444', '#4488FF', '#44DD44', '#DDDD44',
      '#AA44FF', '#FF8844', '#44DDDD', '#FF44AA'
    ];
    const TEAM_COLORS = [
      { r: 255, g: 68, b: 68 },    // Red
      { r: 68, g: 136, b: 255 },   // Blue
      { r: 68, g: 221, b: 68 },    // Green
      { r: 221, g: 221, b: 68 },   // Yellow
      { r: 170, g: 68, b: 255 },   // Purple
      { r: 255, g: 136, b: 68 },   // Orange
      { r: 68, g: 221, b: 221 },   // Cyan
      { r: 255, g: 68, b: 170 }    // Pink
    ];

    let ws = null;
    let playerData = [];   // from server frames: [{ id, x, y, fdx, fdy, score }, ...]
    let playerCount = 2;
    let connectedSet = new Set();
    let playerNames = {};  // { playerId: 'NAME' }
    let projectiles = [];  // [{ x, y, owner }, ...]
    let walls = [];
    let pickups = [];
    let playerPickups = {};
    let gameActive = false;
    let currentRoomId = null;  // room code assigned by server
    let isOwner = false;

    // Soundtracks
    const soundtracks = [
      new Audio('/sound/music/soundtrack_01.mp3'),
      new Audio('/sound/music/soundtrack_02.mp3'),
      new Audio('/sound/music/soundtrack_03.mp3')
    ];
    soundtracks.forEach(a => { a.loop = true; a.volume = 0.4; });
    let currentTrack = null;

    // Lobby / between-rounds music
    const lobbyMusic = new Audio('/sound/music/connect.mp3');
    lobbyMusic.loop = true;
    lobbyMusic.volume = 0.4;

    function playRandomSoundtrack() {
      lobbyMusic.pause(); lobbyMusic.currentTime = 0;
      if (currentTrack) { currentTrack.pause(); currentTrack.currentTime = 0; }
      currentTrack = soundtracks[Math.floor(Math.random() * soundtracks.length)];
      currentTrack.play().catch(() => {});
    }
    function stopSoundtrack() {
      if (currentTrack) { currentTrack.pause(); currentTrack.currentTime = 0; currentTrack = null; }
    }
    function playLobbyMusic() {
      lobbyMusic.play().catch(() => {});
    }
    function stopLobbyMusic() {
      lobbyMusic.pause(); lobbyMusic.currentTime = 0;
    }

    // Sound effects (pooled so multiple can play at once)
    const allSFXAudio = []; // track all Audio objects for unlock
    function createSFXPool(src, poolSize, volume) {
      const pool = [];
      for (let i = 0; i < poolSize; i++) {
        const a = new Audio(src);
        a.volume = volume;
        pool.push(a);
        allSFXAudio.push(a);
      }
      let idx = 0;
      return function() {
        const a = pool[idx];
        a.currentTime = 0;
        a.play().catch(() => {});
        idx = (idx + 1) % pool.length;
      };
    }
    const playShotSFX      = createSFXPool('/sound/sfx/Shot.mp3', 6, 0.3);
    const playExplosionSFX = createSFXPool('/sound/sfx/Explosion.mp3', 6, 0.4);
    const playWallHitSFX   = createSFXPool('/sound/sfx/hit_wall.mp3', 6, 0.3);

    // Explosion animation
    const EXPLOSION_FRAMES = 7;
    const EXPLOSION_FRAME_SIZE = 256; // each frame is 256x256 in spritesheet
    const EXPLOSION_DISPLAY = 64;     // drawn size on canvas
    const EXPLOSION_FPS = 12;
    let explosions = []; // { x, y, frame, lastTick }
    let ricochets = [];  // { x, y, frame, lastTick } — small spark effect
    const RICOCHET_FRAMES = 5;
    const RICOCHET_FPS = 20;
    const explosionImg = new Image();
    explosionImg.src = '/images/effects/explosion.png';

    // ── Dust spritesheet (generated at runtime) ──
    const DUST_FRAMES = 6;
    const DUST_FRAME_SIZE = 48;
    const DUST_DISPLAY = 48;
    const DUST_FPS = 20;
    let dustParticles = [];  // { x, y, frame, lastTick }
    let prevPositions = {};  // playerId -> { x, y }
    let dustSpawnTimer = {}; // playerId -> lastSpawnTime
    const DUST_SPAWN_INTERVAL = 80; // ms between dust spawns per player

    function generateDustSpritesheet() {
      const fs = DUST_FRAME_SIZE;
      const c = document.createElement('canvas');
      c.width = fs * DUST_FRAMES;
      c.height = fs;
      const dctx = c.getContext('2d');

      // Deterministic blob layout
      const blobs = [
        { a: 0.0, d: 0.10, s: 1.00 },
        { a: 1.0, d: 0.35, s: 0.80 },
        { a: 2.2, d: 0.28, s: 0.90 },
        { a: 3.5, d: 0.45, s: 0.60 },
        { a: 4.7, d: 0.22, s: 0.75 },
        { a: 5.8, d: 0.50, s: 0.50 },
        { a: 0.7, d: 0.58, s: 0.45 },
        { a: 2.8, d: 0.38, s: 0.70 },
        { a: 4.2, d: 0.52, s: 0.55 },
        { a: 5.3, d: 0.18, s: 0.85 },
      ];

      for (let f = 0; f < DUST_FRAMES; f++) {
        const cx = f * fs + fs / 2;
        const cy = fs / 2;
        const t = f / (DUST_FRAMES - 1);         // 0 → 1
        const opacity = 0.6 * (1 - t * 0.9);     // fade out
        const spread = 4 + t * 14;                // expand outward

        for (const b of blobs) {
          const bx = cx + Math.cos(b.a) * b.d * spread;
          const by = cy + Math.sin(b.a) * b.d * spread;
          const radius = (2.5 + t * 5) * b.s;
          const bOpacity = opacity * b.s;

          const grad = dctx.createRadialGradient(bx, by, 0, bx, by, radius);
          grad.addColorStop(0, 'rgba(180,165,135,' + bOpacity + ')');
          grad.addColorStop(0.5, 'rgba(160,145,115,' + (bOpacity * 0.5) + ')');
          grad.addColorStop(1, 'rgba(140,125,100,0)');

          dctx.beginPath();
          dctx.arc(bx, by, radius, 0, Math.PI * 2);
          dctx.fillStyle = grad;
          dctx.fill();
        }
      }

      return c;
    }

    const dustSheet = generateDustSpritesheet();

    // ── Smoke spritesheet for damaged tanks (HP <= 50) ──
    const SMOKE_FRAMES = 10;
    const SMOKE_FRAME_SIZE = 40;
    const SMOKE_DISPLAY = 40;
    const SMOKE_FPS = 10;
    let smokeParticles = []; // { x, y, frame, lastTick, vy }
    let smokeSpawnTimer = {};
    const SMOKE_SPAWN_INTERVAL = 120;

    function generateSmokeSpritesheet() {
      const fs = SMOKE_FRAME_SIZE;
      const c = document.createElement('canvas');
      c.width = fs * SMOKE_FRAMES;
      c.height = fs;
      const sctx = c.getContext('2d');

      const blobs = [
        { a: 0.0, d: 0.08, s: 1.00 },
        { a: 1.2, d: 0.30, s: 0.85 },
        { a: 2.5, d: 0.22, s: 0.90 },
        { a: 3.8, d: 0.40, s: 0.65 },
        { a: 5.0, d: 0.18, s: 0.80 },
        { a: 0.5, d: 0.48, s: 0.50 },
        { a: 2.0, d: 0.35, s: 0.75 },
        { a: 4.4, d: 0.42, s: 0.55 },
      ];

      for (let f = 0; f < SMOKE_FRAMES; f++) {
        const cx = f * fs + fs / 2;
        const cy = fs / 2;
        const t = f / (SMOKE_FRAMES - 1);
        const opacity = 0.7 * (1 - t * 0.85);
        const spread = 3 + t * 12;

        for (const b of blobs) {
          const bx = cx + Math.cos(b.a) * b.d * spread;
          const by = cy + Math.sin(b.a) * b.d * spread - t * 4;
          const radius = (2 + t * 6) * b.s;
          const bOpacity = opacity * b.s;

          const grad = sctx.createRadialGradient(bx, by, 0, bx, by, radius);
          grad.addColorStop(0, 'rgba(40,40,40,' + bOpacity + ')');
          grad.addColorStop(0.4, 'rgba(60,55,50,' + (bOpacity * 0.6) + ')');
          grad.addColorStop(1, 'rgba(80,70,60,0)');

          sctx.beginPath();
          sctx.arc(bx, by, radius, 0, Math.PI * 2);
          sctx.fillStyle = grad;
          sctx.fill();
        }
      }

      return c;
    }

    const smokeSheet = generateSmokeSpritesheet();

    // ── Brick wall texture (generated at runtime, tileable) ──
    function generateBrickTexture() {
      const bw = 16, bh = 8;          // brick size
      const mortar = 1;               // mortar line thickness
      const tw = (bw + mortar) * 2;   // tile width (2 bricks wide for offset pattern)
      const th = (bh + mortar) * 2;   // tile height (2 rows)
      const c = document.createElement('canvas');
      c.width = tw;
      c.height = th;
      const bctx = c.getContext('2d');

      // Mortar background
      bctx.fillStyle = '#5a5048';
      bctx.fillRect(0, 0, tw, th);

      // Draw bricks with slight color variation
      const brickColors = ['#8B4513', '#9A5324', '#7E3D10', '#A0522D', '#8F4C1A', '#964B26'];

      function drawBrick(x, y) {
        const col = brickColors[((x * 7 + y * 13) & 0x7FFFFFFF) % brickColors.length];
        bctx.fillStyle = col;
        bctx.fillRect(x, y, bw, bh);
        // Subtle highlight on top edge
        bctx.fillStyle = 'rgba(255,255,255,0.08)';
        bctx.fillRect(x, y, bw, 1);
        // Subtle shadow on bottom edge
        bctx.fillStyle = 'rgba(0,0,0,0.15)';
        bctx.fillRect(x, y + bh - 1, bw, 1);
      }

      // Row 0: aligned bricks
      drawBrick(0, 0);
      drawBrick(bw + mortar, 0);
      // Row 1: offset by half a brick
      const offset = Math.floor(bw / 2) + mortar;
      drawBrick(-bw + offset, bh + mortar);
      drawBrick(offset, bh + mortar);
      drawBrick(offset + bw + mortar, bh + mortar);

      return c;
    }

    const brickTex = generateBrickTexture();
    const brickPattern = ctx.createPattern(brickTex, 'repeat');

    // ── Sandbag texture (generated at runtime, tileable) ──
    function generateSandbagTexture() {
      const bw = 20, bh = 10;       // single bag size
      const gap = 1;                 // gap between bags
      const tw = (bw + gap) * 2;    // tile width (2 bags wide for offset pattern)
      const th = (bh + gap) * 2;    // tile height (2 rows)
      const c = document.createElement('canvas');
      c.width = tw; c.height = th;
      const g = c.getContext('2d');

      // Gap shadow background
      g.fillStyle = '#5a4e3a';
      g.fillRect(0, 0, tw, th);

      const bagColors = ['#c4a96a', '#b89e60', '#cdb476', '#bfa564', '#d1b87e', '#b09555'];

      function drawBag(x, y) {
        const col = bagColors[((x * 3 + y * 7) & 0x7FFFFFFF) % bagColors.length];
        const r = 3; // corner radius

        // Bag body (rounded rect)
        g.beginPath();
        g.moveTo(x + r, y);
        g.lineTo(x + bw - r, y);
        g.quadraticCurveTo(x + bw, y, x + bw, y + r);
        g.lineTo(x + bw, y + bh - r);
        g.quadraticCurveTo(x + bw, y + bh, x + bw - r, y + bh);
        g.lineTo(x + r, y + bh);
        g.quadraticCurveTo(x, y + bh, x, y + bh - r);
        g.lineTo(x, y + r);
        g.quadraticCurveTo(x, y, x + r, y);
        g.closePath();
        g.fillStyle = col;
        g.fill();

        // Highlight on top
        g.fillStyle = 'rgba(255,255,230,0.15)';
        g.fillRect(x + 2, y + 1, bw - 4, 2);

        // Shadow on bottom
        g.fillStyle = 'rgba(0,0,0,0.12)';
        g.fillRect(x + 2, y + bh - 2, bw - 4, 1);

        // Burlap weave lines (horizontal)
        g.strokeStyle = 'rgba(0,0,0,0.06)';
        g.lineWidth = 0.5;
        for (let ly = 2; ly < bh - 1; ly += 3) {
          g.beginPath();
          g.moveTo(x + 1, y + ly);
          g.lineTo(x + bw - 1, y + ly);
          g.stroke();
        }

        // Tie knot in center (small cinch)
        g.fillStyle = 'rgba(90,70,40,0.3)';
        g.beginPath();
        g.ellipse(x + bw / 2, y + bh / 2, 2, 1.5, 0, 0, Math.PI * 2);
        g.fill();
      }

      // Row 0: aligned bags
      drawBag(0, 0);
      drawBag(bw + gap, 0);
      // Row 1: offset by half a bag
      const offset = Math.floor(bw / 2) + gap;
      drawBag(-bw + offset, bh + gap);
      drawBag(offset, bh + gap);
      drawBag(offset + bw + gap, bh + gap);

      return c;
    }

    const sandbagTex = generateSandbagTexture();
    const sandbagPattern = ctx.createPattern(sandbagTex, 'repeat');

    // ── Destructible sandbag walls ──
    let destructCanvas = null;
    let destructCtx = null;
    let destructibles = [];

    function initDestructCanvas(objs) {
      destructibles = objs || [];
      destructCanvas = document.createElement('canvas');
      destructCanvas.width = W;
      destructCanvas.height = H;
      destructCtx = destructCanvas.getContext('2d');
      destructCtx.clearRect(0, 0, W, H);

      for (const obj of destructibles) {
        const hw = obj.w / 2, hh = obj.h / 2;

        destructCtx.save();
        destructCtx.translate(obj.x, obj.y);

        // Sandbag wall body
        destructCtx.fillStyle = sandbagPattern;
        destructCtx.fillRect(-hw, -hh, obj.w, obj.h);

        // Outer dark border (thick, high contrast)
        destructCtx.strokeStyle = 'rgba(30,25,10,0.85)';
        destructCtx.lineWidth = 3;
        destructCtx.strokeRect(-hw, -hh, obj.w, obj.h);

        // Inner lighter edge for depth
        destructCtx.strokeStyle = 'rgba(180,160,110,0.5)';
        destructCtx.lineWidth = 1;
        destructCtx.strokeRect(-hw + 2, -hh + 2, obj.w - 4, obj.h - 4);

        // Top highlight strip
        destructCtx.fillStyle = 'rgba(255,255,230,0.2)';
        destructCtx.fillRect(-hw + 2, -hh + 2, obj.w - 4, 3);

        // Bottom shadow strip
        destructCtx.fillStyle = 'rgba(0,0,0,0.3)';
        destructCtx.fillRect(-hw + 2, hh - 4, obj.w - 4, 3);

        destructCtx.restore();
      }
    }

    function applyDestructHits(hits) {
      if (!destructCtx || !hits || hits.length === 0) return;
      destructCtx.save();
      destructCtx.globalCompositeOperation = 'destination-out';
      for (const dh of hits) {
        destructCtx.beginPath();
        destructCtx.arc(dh.x, dh.y, dh.r, 0, Math.PI * 2);
        destructCtx.fill();
      }
      destructCtx.restore();
    }

    // ── Background textures (splat-map blended: grass + dirt + variation) ──
    const texGrass = new Image();
    const texDirt = new Image();
    const texVar = new Image();
    let texLoadCount = 0;
    let bgCanvas = null;
    let pendingBgSeed = null;

    function onTexLoaded() {
      texLoadCount++;
      if (texLoadCount === 3 && pendingBgSeed !== null) {
        bgCanvas = generateBackground(pendingBgSeed);
        pendingBgSeed = null;
        draw();
      }
    }

    texGrass.onload = onTexLoaded;
    texDirt.onload = onTexLoaded;
    texVar.onload = onTexLoaded;
    texGrass.src = '/images/terrain/tex_grass_tile_512.png';
    texDirt.src = '/images/terrain/tex_dirt_tile_512.png';
    texVar.src = '/images/terrain/tex_grass_variation_tile_512.png';

    function setBgSeed(seed) {
      if (texLoadCount === 3) {
        bgCanvas = generateBackground(seed);
      } else {
        pendingBgSeed = seed;
      }
    }

    // Value noise for procedural splat map generation
    function hash2D(ix, iy, seed) {
      const n = Math.sin(ix * 127.1 + iy * 311.7 + seed * 73.4) * 43758.5453;
      return n - Math.floor(n);
    }

    function smoothNoise(x, y, seed) {
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const sx = fx * fx * (3 - 2 * fx);
      const sy = fy * fy * (3 - 2 * fy);
      const n00 = hash2D(ix, iy, seed);
      const n10 = hash2D(ix + 1, iy, seed);
      const n01 = hash2D(ix, iy + 1, seed);
      const n11 = hash2D(ix + 1, iy + 1, seed);
      return (n00 * (1 - sx) + n10 * sx) * (1 - sy) +
             (n01 * (1 - sx) + n11 * sx) * sy;
    }

    function fbm(x, y, seed, octaves) {
      let val = 0, amp = 1, freq = 1, max = 0;
      for (let i = 0; i < octaves; i++) {
        val += smoothNoise(x * freq, y * freq, seed + i * 100) * amp;
        max += amp;
        amp *= 0.5;
        freq *= 2;
      }
      return val / max;
    }

    function generateBackground(seed) {
      const TS = 512;  // tile texture size
      const TP = 256;  // tile repeat in screen pixels (square tiles)

      // Read pixel data from tile textures
      const tmp = document.createElement('canvas');
      tmp.width = TS; tmp.height = TS;
      const tc = tmp.getContext('2d');

      tc.drawImage(texGrass, 0, 0);
      const grassPx = tc.getImageData(0, 0, TS, TS).data;

      tc.clearRect(0, 0, TS, TS);
      tc.drawImage(texDirt, 0, 0);
      const dirtPx = tc.getImageData(0, 0, TS, TS).data;

      tc.clearRect(0, 0, TS, TS);
      tc.drawImage(texVar, 0, 0);
      const varPx = tc.getImageData(0, 0, TS, TS).data;

      // Output canvas (full battlefield size)
      const bg = document.createElement('canvas');
      bg.width = W; bg.height = H;
      const bCtx = bg.getContext('2d');
      const out = bCtx.createImageData(W, H);
      const od = out.data;

      for (let py = 0; py < H; py++) {
        for (let px = 0; px < W; px++) {
          // Tiled texture coordinates (square tiles)
          const tx = Math.floor(px / TP * TS) % TS;
          const ty = Math.floor(py / TP * TS) % TS;
          const ti = (ty * TS + tx) * 4;

          // Normalized world position for noise
          const nx = px / W;
          const ny = py / H;

          // Dirt weight: organic blobs via FBM noise
          const dirtRaw = fbm(nx * 5, ny * 5, seed, 4);
          const dirtW = Math.max(0, Math.min(1, (dirtRaw - 0.52) * 5));

          // Variation weight: subtle patches, only on non-dirt areas
          const varRaw = fbm(nx * 9, ny * 9, seed + 500, 3);
          const varW = Math.max(0, Math.min(1, varRaw * 0.5)) * (1 - dirtW);

          // Blend: grass base → dirt → variation (same as shader)
          const oi = (py * W + px) * 4;
          for (let c = 0; c < 3; c++) {
            let col = grassPx[ti + c];
            col = col * (1 - dirtW) + dirtPx[ti + c] * dirtW;
            col = col * (1 - varW) + varPx[ti + c] * varW;
            od[oi + c] = col | 0;
          }
          od[oi + 3] = 255;
        }
      }

      bCtx.putImageData(out, 0, 0);
      return bg;
    }

    // ── Damage overlay generator ──
    function createDamagedSprite(srcCanvas, level) {
      const w = srcCanvas.width, h = srcCanvas.height;
      const out = document.createElement('canvas');
      out.width = w; out.height = h;
      const octx = out.getContext('2d');

      // Copy original sprite
      octx.drawImage(srcCanvas, 0, 0);
      const imgData = octx.getImageData(0, 0, w, h);
      const d = imgData.data;

      // Seeded random for consistent damage per sprite
      let seed = level * 9973 + w * 137;
      function rand() { seed = (seed * 16807 + 7) % 2147483647; return (seed & 0x7fffffff) / 0x7fffffff; }

      // Collect solid pixel positions for placing damage
      const solidPixels = [];
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          if (d[(y * w + x) * 4 + 3] > 30) solidPixels.push({ x, y });
        }
      }
      if (solidPixels.length === 0) return out;

      // Overall darkening (simulates soot/dirt)
      const darken = level === 1 ? 0.82 : 0.6;
      for (let i = 0; i < d.length; i += 4) {
        if (d[i + 3] < 10) continue;
        d[i]     = Math.round(d[i] * darken);
        d[i + 1] = Math.round(d[i + 1] * darken);
        d[i + 2] = Math.round(d[i + 2] * darken);
      }

      // Scorch marks (dark circular burns)
      const scorchCount = level === 1 ? 4 : 9;
      for (let s = 0; s < scorchCount; s++) {
        const center = solidPixels[Math.floor(rand() * solidPixels.length)];
        const r = level === 1 ? 2 + rand() * 3 : 3 + rand() * 4;
        for (let dy = -Math.ceil(r); dy <= Math.ceil(r); dy++) {
          for (let dx = -Math.ceil(r); dx <= Math.ceil(r); dx++) {
            const px = center.x + dx, py = center.y + dy;
            if (px < 0 || px >= w || py < 0 || py >= h) continue;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > r) continue;
            const idx = (py * w + px) * 4;
            if (d[idx + 3] < 10) continue;
            const fade = 1 - dist / r;
            const burn = fade * (level === 1 ? 0.4 : 0.7);
            d[idx]     = Math.round(d[idx] * (1 - burn) + 20 * burn);
            d[idx + 1] = Math.round(d[idx + 1] * (1 - burn) + 10 * burn);
            d[idx + 2] = Math.round(d[idx + 2] * (1 - burn) + 5 * burn);
          }
        }
      }

      // Scratch lines (dark streaks)
      const scratchCount = level === 1 ? 3 : 7;
      for (let s = 0; s < scratchCount; s++) {
        const start = solidPixels[Math.floor(rand() * solidPixels.length)];
        const angle = rand() * Math.PI * 2;
        const len = level === 1 ? 6 + rand() * 10 : 10 + rand() * 16;
        for (let t = 0; t < len; t++) {
          const px = Math.round(start.x + Math.cos(angle) * t);
          const py = Math.round(start.y + Math.sin(angle) * t);
          if (px < 0 || px >= w || py < 0 || py >= h) break;
          const idx = (py * w + px) * 4;
          if (d[idx + 3] < 10) continue;
          d[idx]     = Math.round(d[idx] * 0.3 + 15);
          d[idx + 1] = Math.round(d[idx + 1] * 0.3 + 10);
          d[idx + 2] = Math.round(d[idx + 2] * 0.3 + 5);
        }
      }

      // Holes (transparent chunks) — severe damage only
      if (level === 2) {
        const holeCount = 2 + Math.floor(rand() * 3);
        for (let h2 = 0; h2 < holeCount; h2++) {
          const center = solidPixels[Math.floor(rand() * solidPixels.length)];
          const r = 2 + rand() * 3;
          for (let dy = -Math.ceil(r); dy <= Math.ceil(r); dy++) {
            for (let dx = -Math.ceil(r); dx <= Math.ceil(r); dx++) {
              const px = center.x + dx, py2 = center.y + dy;
              if (px < 0 || px >= w || py2 < 0 || py2 >= h) continue;
              if (Math.sqrt(dx * dx + dy * dy) > r) continue;
              const idx = (py2 * w + px) * 4;
              d[idx + 3] = 0; // punch hole
            }
          }
          // Dark ring around hole
          for (let dy = -Math.ceil(r + 2); dy <= Math.ceil(r + 2); dy++) {
            for (let dx = -Math.ceil(r + 2); dx <= Math.ceil(r + 2); dx++) {
              const px = center.x + dx, py2 = center.y + dy;
              if (px < 0 || px >= w || py2 < 0 || py2 >= h) continue;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= r || dist > r + 2) continue;
              const idx = (py2 * w + px) * 4;
              if (d[idx + 3] < 10) continue;
              d[idx] = Math.round(d[idx] * 0.4);
              d[idx + 1] = Math.round(d[idx + 1] * 0.3);
              d[idx + 2] = Math.round(d[idx + 2] * 0.2);
            }
          }
        }
      }

      octx.putImageData(imgData, 0, 0);
      return out;
    }

    // ── Tank sprite compositing (3-layer: base_ramp + team_mask + details) ──
    let tankSprites = {};      // keyed by color index 0-7
    let tankSpritesDmg1 = {};  // light damage (HP 51-99)
    let tankSpritesDmg2 = {};  // severe damage (HP 1-50)
    let spritesReady = false;

    const rampImg = new Image();
    const maskImg = new Image();
    const detailsImg = new Image();
    let imagesLoaded = 0;

    function onImageLoad() {
      imagesLoaded++;
      if (imagesLoaded < 3) return;

      const iw = rampImg.width, ih = rampImg.height;

      // Read ramp pixel data
      const rampCanvas = document.createElement('canvas');
      rampCanvas.width = iw; rampCanvas.height = ih;
      const rampCtx = rampCanvas.getContext('2d');
      rampCtx.drawImage(rampImg, 0, 0);
      const rampData = rampCtx.getImageData(0, 0, iw, ih);

      // Read mask pixel data
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = maskImg.width; maskCanvas.height = maskImg.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.drawImage(maskImg, 0, 0);
      const maskData = maskCtx.getImageData(0, 0, maskImg.width, maskImg.height);

      // Read details pixel data
      const detCanvas = document.createElement('canvas');
      detCanvas.width = detailsImg.width; detCanvas.height = detailsImg.height;
      const detCtx = detCanvas.getContext('2d');
      detCtx.drawImage(detailsImg, 0, 0);
      const detData = detCtx.getImageData(0, 0, detailsImg.width, detailsImg.height);

      // Find tight bounding box from ramp + details combined
      let minX = iw, minY = ih, maxX = 0, maxY = 0;
      for (let y = 0; y < ih; y++) {
        for (let x = 0; x < iw; x++) {
          const idx = (y * iw + x) * 4;
          const rampA = rampData.data[idx + 3];
          const detA = (x < detailsImg.width && y < detailsImg.height)
            ? detData.data[(y * detailsImg.width + x) * 4 + 3] : 0;
          if (rampA > 10 || detA > 10) {
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }

      minX = Math.max(0, minX - 2);
      minY = Math.max(0, minY - 2);
      maxX = Math.min(iw - 1, maxX + 2);
      maxY = Math.min(ih - 1, maxY + 2);
      const cropW = maxX - minX + 1;
      const cropH = maxY - minY + 1;

      // Composite all 8 team color variants
      for (let ti = 0; ti < 8; ti++) {
        const tc = TEAM_COLORS[ti];
        const out = document.createElement('canvas');
        out.width = cropW;
        out.height = cropH;
        const outCtx = out.getContext('2d');
        const outImgData = outCtx.createImageData(cropW, cropH);

        for (let y = 0; y < cropH; y++) {
          for (let x = 0; x < cropW; x++) {
            const srcX = minX + x;
            const srcY = minY + y;
            const outIdx = (y * cropW + x) * 4;

            // Read ramp pixel
            const rIdx = (srcY * iw + srcX) * 4;
            const rR = rampData.data[rIdx];
            const rG = rampData.data[rIdx + 1];
            const rB = rampData.data[rIdx + 2];
            const rA = rampData.data[rIdx + 3];

            // Read mask pixel
            let maskBright = 255;
            if (srcX < maskImg.width && srcY < maskImg.height) {
              const mIdx = (srcY * maskImg.width + srcX) * 4;
              const mA = maskData.data[mIdx + 3];
              if (mA > 10) {
                maskBright = (maskData.data[mIdx] + maskData.data[mIdx + 1] + maskData.data[mIdx + 2]) / 3;
              } else {
                maskBright = 0;
              }
            }

            // Step 1: Team-color the base ramp
            let bR, bG, bB, bA;
            if (rA < 10) {
              bR = 0; bG = 0; bB = 0; bA = 0;
            } else if (maskBright > 128) {
              // Multiply blend: ramp * teamColor
              bR = Math.round(rR * tc.r / 255);
              bG = Math.round(rG * tc.g / 255);
              bB = Math.round(rB * tc.b / 255);
              bA = rA;
            } else {
              // Keep ramp as-is (non-team areas)
              bR = rR; bG = rG; bB = rB; bA = rA;
            }

            // Step 2: Alpha-composite details layer on top
            let detR = 0, detG = 0, detB = 0, detA = 0;
            if (srcX < detailsImg.width && srcY < detailsImg.height) {
              const dIdx = (srcY * detailsImg.width + srcX) * 4;
              detR = detData.data[dIdx];
              detG = detData.data[dIdx + 1];
              detB = detData.data[dIdx + 2];
              detA = detData.data[dIdx + 3];
            }

            if (detA > 0) {
              // Standard alpha compositing: detail over base
              const dA = detA / 255;
              const invDA = 1 - dA;
              const outA = dA + (bA / 255) * invDA;
              if (outA > 0) {
                outImgData.data[outIdx]     = Math.round((detR * dA + bR * (bA / 255) * invDA) / outA);
                outImgData.data[outIdx + 1] = Math.round((detG * dA + bG * (bA / 255) * invDA) / outA);
                outImgData.data[outIdx + 2] = Math.round((detB * dA + bB * (bA / 255) * invDA) / outA);
                outImgData.data[outIdx + 3] = Math.round(outA * 255);
              } else {
                outImgData.data[outIdx + 3] = 0;
              }
            } else {
              // No detail pixel — use base directly
              outImgData.data[outIdx]     = bR;
              outImgData.data[outIdx + 1] = bG;
              outImgData.data[outIdx + 2] = bB;
              outImgData.data[outIdx + 3] = bA;
            }
          }
        }

        outCtx.putImageData(outImgData, 0, 0);
        tankSprites[ti] = out;
      }

      // Generate damaged variants from the clean sprites
      for (let ti = 0; ti < 8; ti++) {
        tankSpritesDmg1[ti] = createDamagedSprite(tankSprites[ti], 1);
        tankSpritesDmg2[ti] = createDamagedSprite(tankSprites[ti], 2);
      }

      spritesReady = true;
      console.log('Tank sprites ready:', cropW, 'x', cropH);
      draw();
    }

    rampImg.onload = onImageLoad;
    maskImg.onload = onImageLoad;
    detailsImg.onload = onImageLoad;
    rampImg.src = '/images/tanks/tank_base_ramp.png';
    maskImg.src = '/images/tanks/tank_team_mask_new.png';
    detailsImg.src = '/images/tanks/tank_details.png';

    // ── Player count selector buttons ──
    const countBtnsContainer = document.getElementById('count-buttons');
    for (let n = 2; n <= 7; n++) {
      const btn = document.createElement('button');
      btn.className = 'count-btn' + (n === 2 ? ' active' : '');
      btn.textContent = n;
      btn.dataset.count = n;
      btn.addEventListener('click', () => {
        if (gameActive) return;
        document.querySelectorAll('.count-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'set_player_count', count: n }));
        }
      });
      countBtnsContainer.appendChild(btn);
    }

    // ── Bot controls ──
    document.getElementById('add-bot-btn').addEventListener('click', () => {
      if (gameActive) return;
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'add_bot' }));
      }
    });
    document.getElementById('remove-bot-btn').addEventListener('click', () => {
      if (gameActive) return;
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'remove_bot' }));
      }
    });

    // ── Lobby setup (dynamic, set after room is joined) ──
    function updateLobbyUrl() {
      const controllerUrl = location.origin + '/controller.html' + (currentRoomId ? '?room=' + currentRoomId : '');
      document.getElementById('lobby-url').textContent = controllerUrl;
      if (window.qrcode) {
        const qr = qrcode(0, 'M');
        qr.addData(controllerUrl);
        qr.make();
        document.getElementById('qr-code').innerHTML = qr.createSvgTag(5);
      }
      document.getElementById('room-code-badge').textContent = 'ROOM: ' + (currentRoomId || '...');
    }

    function buildLobby(playersInfo) {
      const container = document.getElementById('player-codes');
      container.innerHTML = '';
      let botCount = 0;
      for (const p of playersInfo) {
        const color = PLAYER_HEX_COLORS[p.id - 1];
        const isBot = p.isBot || false;
        if (isBot) botCount++;
        const box = document.createElement('div');
        box.className = 'player-code-box';
        box.id = 'code-box-' + p.id;
        box.style.background = color + '22';
        box.style.border = '2px solid ' + color;
        const displayName = playerNames[p.id] || p.name || ('Player ' + p.id);
        if (isBot) {
          box.innerHTML =
            '<div class="label">' + displayName + '</div>' +
            '<div class="code" style="font-size:16px;">BOT</div>' +
            '<div class="status connected" id="status-p' + p.id + '">Bot Player</div>';
        } else {
          box.innerHTML =
            '<div class="label">' + displayName + '</div>' +
            '<div class="code">' + p.code + '</div>' +
            '<div class="status ' + (p.connected ? 'connected' : 'waiting') + '" id="status-p' + p.id + '">' +
              (p.connected ? 'Connected!' : 'Waiting...') +
            '</div>';
        }
        container.appendChild(box);
      }
      playerCount = playersInfo.length;
      // Update bot count label
      const botLabel = document.getElementById('bot-count-label');
      if (botLabel) botLabel.textContent = botCount + ' bot' + (botCount !== 1 ? 's' : '');
      // Highlight correct count button
      document.querySelectorAll('.count-btn').forEach(b => {
        b.classList.toggle('active', parseInt(b.dataset.count) === playerCount);
      });
    }

    function buildScoreboard() {
      const sb = document.getElementById('scoreboard');
      sb.innerHTML = '';
      for (const p of playerData) {
        const color = PLAYER_HEX_COLORS[p.id - 1];
        const item = document.createElement('div');
        item.className = 'score-item';
        const sbName = playerNames[p.id] || ('P' + p.id);
        item.innerHTML =
          '<span class="score-dot" style="background:' + color + '"></span>' +
          '<span>' + sbName + ': <span id="score-p' + p.id + '">' + p.score + '</span></span>';
        sb.appendChild(item);
      }
    }

    function updateScoreboard() {
      for (const p of playerData) {
        const el = document.getElementById('score-p' + p.id);
        if (el) el.textContent = p.score;
      }
    }

    function updateLobbyStatus() {
      let totalBots = 0;
      for (const p of playerData) {
        if (p.isBot) totalBots++;
      }
      for (let i = 1; i <= playerCount; i++) {
        const el = document.getElementById('status-p' + i);
        if (!el) continue;
        const pData = playerData.find(pd => pd.id === i);
        if (pData && pData.isBot) continue; // bots stay as "Bot Player"
        const conn = connectedSet.has(i);
        el.textContent = conn ? 'Connected!' : 'Waiting...';
        el.className = 'status ' + (conn ? 'connected' : 'waiting');
      }
      const humanCount = playerCount - totalBots;
      const humanConnected = connectedSet.size - totalBots;
      if (humanConnected >= humanCount) {
        document.getElementById('lobby-status').textContent = 'All players connected! Starting...';
      } else {
        document.getElementById('lobby-status').textContent =
          humanConnected + '/' + humanCount + ' players connected — Open the URL above on your phone';
      }
    }

    // ── WebSocket ──
    let shouldRegister = false; // true when we need to send register_game on connect
    let targetRoomId = null;    // room ID to request (null = create new)

    function connectToRoom(roomId) {
      shouldRegister = true;
      targetRoomId = roomId;
      if (ws) { try { ws.close(); } catch {} }
      connect();
    }

    function connect() {
      const url = (window.WS_URL || ((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host));
      ws = new WebSocket(url);

      ws.onopen = () => {
        document.getElementById('status-text').textContent = 'Connected';
        if (currentRoomId) {
          // Reconnecting to an existing room
          ws.send(JSON.stringify({ type: 'register_game', roomId: currentRoomId }));
        } else if (shouldRegister) {
          // First connection — create or join room
          ws.send(JSON.stringify({ type: 'register_game', roomId: targetRoomId }));
        }
      };

      ws.onmessage = (e) => {
        const msg = JSON.parse(e.data);

        switch (msg.type) {
          case 'room_joined':
            currentRoomId = msg.roomId;
            isOwner = !!msg.isOwner;
            document.getElementById('room-picker').classList.add('hidden');
            document.querySelector('.player-count-selector').style.display = isOwner ? '' : 'none';
            document.querySelector('.bot-controls').style.display = isOwner ? '' : 'none';
            updateLobbyUrl();
            break;

          case 'owner_transfer':
            isOwner = true;
            document.querySelector('.player-count-selector').style.display = '';
            document.querySelector('.bot-controls').style.display = '';
            break;

          case 'error':
            document.getElementById('room-error').textContent = msg.message || 'Error';
            break;

          case 'init':
            connectedSet.clear();
            playerNames = {};
            msg.players.forEach(p => {
              if (p.connected) connectedSet.add(p.id);
              if (p.name) playerNames[p.id] = p.name;
            });
            if (msg.walls) walls = msg.walls;
            if (msg.destructibles) initDestructCanvas(msg.destructibles);
            if (msg.bgSeed != null) setBgSeed(msg.bgSeed);
            buildLobby(msg.players);
            // Init playerData for drawing
            playerData = msg.players.map(p => ({
              id: p.id, x: 0, y: 0, fdx: 0, fdy: -1, score: p.score, isBot: p.isBot || false
            }));
            buildScoreboard();
            updateLobbyStatus();
            break;

          case 'player_joined':
            connectedSet.add(msg.playerId);
            if (msg.name) playerNames[msg.playerId] = msg.name;
            updateLobbyStatus();
            break;

          case 'player_left':
            connectedSet.delete(msg.playerId);
            updateLobbyStatus();
            break;

          case 'game_start':
            gameActive = true;
            playRandomSoundtrack();
            if (msg.walls) walls = msg.walls;
            if (msg.destructibles) initDestructCanvas(msg.destructibles);
            if (msg.bgSeed != null) setBgSeed(msg.bgSeed);
            if (!msg.keepScores) {
              playerData.forEach(p => { p.score = 0; });
            }
            dustParticles = [];
            smokeParticles = [];
            ricochets = [];
            pickups = [];
            playerPickups = {};
            prevPositions = {};
            dustSpawnTimer = {};
            smokeSpawnTimer = {};
            buildScoreboard();
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('winner-overlay').classList.remove('show');
            break;

          case 'game_over': {
            gameActive = false;
            stopSoundtrack();
            playLobbyMusic();
            const winnerId = msg.winnerId;
            const winnerColor = winnerId ? PLAYER_HEX_COLORS[winnerId - 1] : '#fff';
            // Update names from game_over
            if (msg.names) {
              for (const id of Object.keys(msg.names)) playerNames[id] = msg.names[id];
            }
            const winnerName = winnerId ? (playerNames[winnerId] || ('P' + winnerId)) : null;
            document.getElementById('winner-text').textContent =
              winnerName ? winnerName + ' WINS!' : 'DRAW!';
            document.getElementById('winner-text').style.color = winnerColor;
            // Show all scores
            if (msg.scores) {
              const parts = [];
              for (const id of Object.keys(msg.scores).sort()) {
                const sName = playerNames[id] || ('P' + id);
                parts.push(sName + ': ' + msg.scores[id] + ' wins');
              }
              document.getElementById('winner-scores').textContent = parts.join('  |  ');
              // Update playerData scores
              for (const p of playerData) {
                if (msg.scores[p.id] != null) p.score = msg.scores[p.id];
              }
              updateScoreboard();
            }
            document.getElementById('winner-overlay').classList.add('show');
            break;
          }

          case 'ready_update': {
            const rs = msg.readyState || {};
            const parts = [];
            for (const p of playerData) {
              const name = playerNames[p.id] || ('P' + p.id);
              if (rs[p.id]) {
                parts.push('<span class="ready">' + name + ': Ready</span>');
              } else {
                parts.push('<span class="not-ready">' + name + ': Not Ready</span>');
              }
            }
            document.getElementById('ready-status').innerHTML = parts.join('&nbsp;&nbsp;|&nbsp;&nbsp;');
            break;
          }

          case 'game_paused':
            gameActive = false;
            stopSoundtrack();
            playLobbyMusic();
            document.getElementById('lobby').classList.remove('hidden');
            document.getElementById('lobby-status').textContent =
              'Player disconnected — waiting for reconnect...';
            break;

          case 'frame': {
            playerData = msg.players;
            projectiles = msg.projectiles || [];
            pickups = msg.pickups || [];
            playerPickups = msg.playerPickups || {};
            // Update name cache from frame data
            for (const p of playerData) {
              if (p.name) playerNames[p.id] = p.name;
            }

            // Spawn explosions at projectile impact positions + play SFX
            if (msg.hits && msg.hits.length > 0) {
              for (const hit of msg.hits) {
                if (hit.hitType === 'ricochet') {
                  ricochets.push({ x: hit.x, y: hit.y, frame: 0, lastTick: Date.now() });
                  playWallHitSFX();
                } else {
                  explosions.push({ x: hit.x, y: hit.y, frame: 0, lastTick: Date.now() });
                  if (hit.hitType === 'tank') playExplosionSFX();
                  else playWallHitSFX();
                }
              }
            }

            // Play shot sounds
            if (msg.shots && msg.shots.length > 0) {
              for (const s of msg.shots) playShotSFX();
            }

            // Apply destructible terrain hits
            applyDestructHits(msg.destructHits);

            // Spawn dust behind moving tanks
            const now = Date.now();
            for (const p of playerData) {
              if (p.alive === false) continue;
              const prev = prevPositions[p.id];
              if (prev) {
                const dx = p.x - prev.x;
                const dy = p.y - prev.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.5) {
                  const lastSpawn = dustSpawnTimer[p.id] || 0;
                  if (now - lastSpawn > DUST_SPAWN_INTERVAL) {
                    // Spawn at rear of tank, spread across both treads
                    const moveAngle = Math.atan2(dy, dx);
                    const perpX = -Math.sin(moveAngle); // perpendicular to movement
                    const perpY =  Math.cos(moveAngle);
                    const rearX = p.x - Math.cos(moveAngle) * 16;
                    const rearY = p.y - Math.sin(moveAngle) * 16;
                    const treadOffset = TANK_DISPLAY * 0.4; // distance from center to each tread
                    // Left tread dust
                    dustParticles.push({
                      x: rearX + perpX * treadOffset + (Math.random() - 0.5) * 6,
                      y: rearY + perpY * treadOffset + (Math.random() - 0.5) * 6,
                      frame: 0, lastTick: now
                    });
                    // Right tread dust
                    dustParticles.push({
                      x: rearX - perpX * treadOffset + (Math.random() - 0.5) * 6,
                      y: rearY - perpY * treadOffset + (Math.random() - 0.5) * 6,
                      frame: 0, lastTick: now
                    });
                    dustSpawnTimer[p.id] = now;
                  }
                }
              }
              prevPositions[p.id] = { x: p.x, y: p.y };
            }

            // Spawn smoke on damaged tanks (HP <= 50)
            for (const p of playerData) {
              if (p.alive === false) continue;
              const hp = p.hp != null ? p.hp : 100;
              if (hp <= 50) {
                const lastSmoke = smokeSpawnTimer[p.id] || 0;
                if (now - lastSmoke > SMOKE_SPAWN_INTERVAL) {
                  smokeParticles.push({
                    x: p.x + (Math.random() - 0.5) * 16,
                    y: p.y + (Math.random() - 0.5) * 10,
                    frame: 0, lastTick: now,
                    vy: -(0.3 + Math.random() * 0.4)
                  });
                  smokeSpawnTimer[p.id] = now;
                }
              }
            }

            updateScoreboard();
            draw();
            break;
          }
        }
      };

      ws.onclose = () => {
        document.getElementById('status-text').textContent = 'Disconnected';
        // Only auto-reconnect if we're already in a room
        if (currentRoomId) {
          document.getElementById('status-text').textContent = 'Disconnected — reconnecting...';
          setTimeout(connect, 1000);
        }
      };
    }

    // ── Rendering ──
    function draw() {
      // Texture-blended background (splat map)
      if (bgCanvas) {
        ctx.drawImage(bgCanvas, 0, 0);
      } else {
        ctx.fillStyle = '#3a6b1e';
        ctx.fillRect(0, 0, W, H);
      }

      // Subtle grid lines
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= W; x += 40) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y <= H; y += 40) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Draw wall obstacles (brick texture, rotated)
      for (const wall of walls) {
        ctx.save();
        ctx.translate(wall.x, wall.y);
        ctx.rotate(wall.angle || 0);
        ctx.fillStyle = brickPattern;
        ctx.fillRect(-wall.w / 2, -wall.h / 2, wall.w, wall.h);
        ctx.strokeStyle = '#3a2a1a';
        ctx.lineWidth = 1;
        ctx.strokeRect(-wall.w / 2, -wall.h / 2, wall.w, wall.h);
        ctx.restore();
      }

      // Draw destructible rock formations (with holes)
      if (destructCanvas) {
        ctx.drawImage(destructCanvas, 0, 0);
      }

      // Draw pickups
      for (const pickup of pickups) {
        drawPickup(pickup);
      }

      // Draw dust particles (behind tanks)
      {
        const now = Date.now();
        const frameInterval = 1000 / DUST_FPS;
        dustParticles = dustParticles.filter(d => d.frame < DUST_FRAMES);
        for (const d of dustParticles) {
          while (now - d.lastTick >= frameInterval && d.frame < DUST_FRAMES) {
            d.frame++;
            d.lastTick += frameInterval;
          }
          if (d.frame < DUST_FRAMES) {
            const sx = d.frame * DUST_FRAME_SIZE;
            const half = DUST_DISPLAY / 2;
            ctx.drawImage(
              dustSheet,
              sx, 0, DUST_FRAME_SIZE, DUST_FRAME_SIZE,
              d.x - half, d.y - half, DUST_DISPLAY, DUST_DISPLAY
            );
          }
        }
      }

      // Draw projectiles
      for (const proj of projectiles) {
        const color = PLAYER_HEX_COLORS[proj.owner - 1] || '#fff';
        drawProjectile(proj.x, proj.y, color);
      }

      // Draw players (alive only)
      for (const p of playerData) {
        if (p.alive === false) continue;
        drawPlayer(p);
      }

      // Draw smoke on damaged tanks
      {
        const now = Date.now();
        const frameInterval = 1000 / SMOKE_FPS;
        smokeParticles = smokeParticles.filter(s => s.frame < SMOKE_FRAMES);
        for (const s of smokeParticles) {
          s.y += s.vy;
          while (now - s.lastTick >= frameInterval && s.frame < SMOKE_FRAMES) {
            s.frame++;
            s.lastTick += frameInterval;
          }
          if (s.frame < SMOKE_FRAMES) {
            const sx = s.frame * SMOKE_FRAME_SIZE;
            const half = SMOKE_DISPLAY / 2;
            ctx.drawImage(
              smokeSheet,
              sx, 0, SMOKE_FRAME_SIZE, SMOKE_FRAME_SIZE,
              s.x - half, s.y - half, SMOKE_DISPLAY, SMOKE_DISPLAY
            );
          }
        }
      }

      // Draw explosion animations (on top of tanks)
      if (explosionImg.complete && explosionImg.naturalWidth > 0) {
        const now = Date.now();
        const frameInterval = 1000 / EXPLOSION_FPS;
        explosions = explosions.filter(e => e.frame < EXPLOSION_FRAMES);
        for (const e of explosions) {
          while (now - e.lastTick >= frameInterval && e.frame < EXPLOSION_FRAMES) {
            e.frame++;
            e.lastTick += frameInterval;
          }
          if (e.frame < EXPLOSION_FRAMES) {
            const sx = e.frame * EXPLOSION_FRAME_SIZE;
            const half = EXPLOSION_DISPLAY / 2;
            ctx.drawImage(
              explosionImg,
              sx, 0, EXPLOSION_FRAME_SIZE, EXPLOSION_FRAME_SIZE,
              e.x - half, e.y - half, EXPLOSION_DISPLAY, EXPLOSION_DISPLAY
            );
          }
        }
      }

      // Draw ricochet sparks
      {
        const now = Date.now();
        const frameInterval = 1000 / RICOCHET_FPS;
        ricochets = ricochets.filter(r => r.frame < RICOCHET_FRAMES);
        for (const r of ricochets) {
          while (now - r.lastTick >= frameInterval && r.frame < RICOCHET_FRAMES) {
            r.frame++;
            r.lastTick += frameInterval;
          }
          if (r.frame < RICOCHET_FRAMES) {
            const t = r.frame / RICOCHET_FRAMES;
            const size = 12 + t * 8;
            const alpha = 1 - t;
            // Bright yellow-white spark
            const grad = ctx.createRadialGradient(r.x, r.y, 0, r.x, r.y, size);
            grad.addColorStop(0, 'rgba(255,255,220,' + alpha + ')');
            grad.addColorStop(0.4, 'rgba(255,200,60,' + (alpha * 0.6) + ')');
            grad.addColorStop(1, 'rgba(255,150,0,0)');
            ctx.beginPath();
            ctx.arc(r.x, r.y, size, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            // Small bright core
            ctx.beginPath();
            ctx.arc(r.x, r.y, 3 * (1 - t), 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,' + alpha + ')';
            ctx.fill();
          }
        }
      }
    }

    function drawProjectile(x, y, color) {
      // Glow
      const grad = ctx.createRadialGradient(x, y, 0, x, y, PR + 6);
      grad.addColorStop(0, color + 'AA');
      grad.addColorStop(1, color + '00');
      ctx.beginPath();
      ctx.arc(x, y, PR + 6, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();

      // Core
      ctx.beginPath();
      ctx.arc(x, y, PR, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();

      // Colored ring
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawPickup(pickup) {
      const x = pickup.x, y = pickup.y, r = 15;
      const t = Date.now() / 300;
      const pulse = 0.6 + 0.4 * Math.sin(t);
      const glowR = r * (2.5 + 0.8 * Math.sin(t));

      let baseColor, glowInner, glowOuter;
      if (pickup.type === 'heal') {
        baseColor = 'rgba(220, 40, 40, 0.9)';
        glowInner = 'rgba(255, 80, 80, ' + (0.4 + 0.25 * pulse) + ')';
        glowOuter = 'rgba(255, 40, 40, 0)';
      } else if (pickup.type === 'speed') {
        baseColor = 'rgba(230, 210, 40, 0.9)';
        glowInner = 'rgba(255, 255, 80, ' + (0.4 + 0.25 * pulse) + ')';
        glowOuter = 'rgba(255, 240, 40, 0)';
      } else {
        baseColor = 'rgba(80, 130, 220, 0.9)';
        glowInner = 'rgba(120, 170, 255, ' + (0.4 + 0.25 * pulse) + ')';
        glowOuter = 'rgba(80, 140, 255, 0)';
      }

      // Outer glow
      const grad = ctx.createRadialGradient(x, y, r * 0.5, x, y, glowR);
      grad.addColorStop(0, glowInner);
      grad.addColorStop(1, glowOuter);
      ctx.beginPath();
      ctx.arc(x, y, glowR, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();

      // Circle
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = baseColor;
      ctx.fill();

      // Bright rim
      ctx.strokeStyle = 'rgba(255,255,255,' + (0.4 + 0.3 * pulse) + ')';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Icon
      ctx.fillStyle = '#fff';
      if (pickup.type === 'heal') {
        ctx.fillRect(x - 2, y - 7, 4, 14);
        ctx.fillRect(x - 7, y - 2, 14, 4);
      } else if (pickup.type === 'speed') {
        ctx.beginPath();
        ctx.moveTo(x + 2, y - 9);
        ctx.lineTo(x - 4, y + 1);
        ctx.lineTo(x, y + 1);
        ctx.lineTo(x - 2, y + 9);
        ctx.lineTo(x + 4, y - 1);
        ctx.lineTo(x, y - 1);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x + 7, y - 4);
        ctx.lineTo(x + 7, y + 2);
        ctx.quadraticCurveTo(x + 5, y + 8, x, y + 10);
        ctx.quadraticCurveTo(x - 5, y + 8, x - 7, y + 2);
        ctx.lineTo(x - 7, y - 4);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawPlayer(p) {
      const colorIdx = p.id - 1;
      const color = PLAYER_HEX_COLORS[colorIdx] || '#fff';

      if (spritesReady && tankSprites[colorIdx]) {
        const hp = p.hp != null ? p.hp : 100;
        const sprite = hp > 50 ? (hp >= 100 ? tankSprites[colorIdx] : tankSpritesDmg1[colorIdx]) : tankSpritesDmg2[colorIdx];
        const angle = Math.atan2(p.fdy, p.fdx) - Math.PI / 2;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(angle);
        const scale = TANK_DISPLAY / Math.max(sprite.width, sprite.height);
        const dw = sprite.width * scale;
        const dh = sprite.height * scale;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(sprite, -dw / 2, -dh / 2, dw, dh);
        ctx.restore();
      } else {
        // Fallback circle while sprites load
        ctx.beginPath();
        ctx.arc(p.x, p.y, R, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // HP bar above tank
      const barW = 36, barH = 4;
      const barX = p.x - barW / 2;
      const barY = p.y - TANK_DISPLAY / 2 - 10;
      const hpRatio = (p.hp != null ? p.hp : 100) / 100;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = hpRatio > 0.5 ? '#4CAF50' : hpRatio > 0.25 ? '#FF9800' : '#F44336';
      ctx.fillRect(barX, barY, barW * hpRatio, barH);
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(barX, barY, barW, barH);

      // Heal cross indicator: red = ready, green = healing active, black = cooldown
      {
        const crossX = barX + barW + 5;
        const crossY = barY + barH / 2;
        ctx.fillStyle = p.healing ? '#4CAF50' : (p.healReady ? '#F44336' : '#000000');
        ctx.fillRect(crossX, crossY - 4, 2, 8);   // vertical
        ctx.fillRect(crossX - 3, crossY - 1, 8, 2); // horizontal
      }

      // Player label below tank
      ctx.fillStyle = color;
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const tankLabel = playerNames[p.id] || ('P' + p.id);
      ctx.fillText(tankLabel + ': ' + p.score, p.x, p.y + TANK_DISPLAY / 2 + 10);

      // Pickup indicators
      if (playerPickups[p.id]) {
        const pp = playerPickups[p.id];
        let dotIdx = 0;
        const dotY = p.y + TANK_DISPLAY / 2 + 20;
        const dotR = 3;
        const dotSpacing = 9;
        const dotStartX = p.x - 9;
        if (pp.speed) {
          ctx.beginPath();
          ctx.arc(dotStartX + dotIdx * dotSpacing, dotY, dotR, 0, Math.PI * 2);
          ctx.fillStyle = '#DDDD44';
          ctx.fill();
          dotIdx++;
        }
        if (pp.armour) {
          ctx.beginPath();
          ctx.arc(dotStartX + dotIdx * dotSpacing, dotY, dotR, 0, Math.PI * 2);
          ctx.fillStyle = '#4488FF';
          ctx.fill();
          dotIdx++;
        }
        if (pp.heal) {
          ctx.fillStyle = '#FF4444';
          const cx2 = dotStartX + dotIdx * dotSpacing;
          ctx.fillRect(cx2 - 1, dotY - 3, 2, 6);
          ctx.fillRect(cx2 - 3, dotY - 1, 6, 2);
        }
      }
    }

    // ── Room picker ──
    document.getElementById('create-room-btn').addEventListener('click', () => {
      document.getElementById('room-error').textContent = '';
      connectToRoom(null); // null = server generates room ID
    });

    document.getElementById('join-room-btn').addEventListener('click', () => {
      const roomId = document.getElementById('room-id-input').value.trim().toUpperCase();
      if (roomId.length < 4) {
        document.getElementById('room-error').textContent = 'Enter a 4-character room code';
        return;
      }
      document.getElementById('room-error').textContent = '';
      connectToRoom(roomId);
    });

    document.getElementById('room-id-input').addEventListener('input', (e) => {
      e.target.value = e.target.value.toUpperCase();
    });
    document.getElementById('room-id-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') document.getElementById('join-room-btn').click();
    });

    // Check URL for ?room=XXXX (auto-join as spectator)
    const urlParams = new URLSearchParams(window.location.search);
    const urlRoom = urlParams.get('room');

    // ── Initial draw ──
    draw();

    // ── Connect ──
    // Only auto-connect if URL has ?room= parameter; otherwise wait for user action
    if (urlRoom) {
      connectToRoom(urlRoom.toUpperCase());
    }

    // Unlock ALL audio on first user interaction (browsers block autoplay)
    let audioUnlocked = false;
    function unlockAudio() {
      if (audioUnlocked) return;
      audioUnlocked = true;
      // Collect every Audio element on the page and play+pause to unlock
      const allAudio = document.querySelectorAll('audio');
      allAudio.forEach(a => { a.play().then(() => { a.pause(); a.currentTime = 0; }).catch(() => {}); });
      // Also unlock programmatically created Audio objects (music + SFX pools)
      const audioObjects = [lobbyMusic, ...soundtracks, ...allSFXAudio];
      audioObjects.forEach(a => { a.play().then(() => { a.pause(); a.currentTime = 0; }).catch(() => {}); });
      // Now actually start lobby music
      setTimeout(() => playLobbyMusic(), 100);
      document.removeEventListener('click', unlockAudio);
      document.removeEventListener('keydown', unlockAudio);
    }
    document.addEventListener('click', unlockAudio);
    document.addEventListener('keydown', unlockAudio);
    // Also try immediately (works if browser allows autoplay)
    playLobbyMusic();
  </script>
</body>
</html>
